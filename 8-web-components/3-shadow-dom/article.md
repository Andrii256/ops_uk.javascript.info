# Shadow DOM

Тіньовий DOM ('Shadow DOM') використовується для інкапсуляції. Він дозволяє компоненту мати своє власне "тіньове" DOM-дерево, що не може бути випадково доступним з головного документу, a також може мати власні локальні правила стилів, та ін.

## Вбудований shadow DOM

Чи замислювались ви коли-небудь, як влаштовані та стилізовані складні браузерні елементи керування?

Такі як `<input type="range">`:

<p>
<input type="range">
</p>

Браузер використовує DOM/CSS на свій розсуд, щоб відобразити їх. Така структура DOM зазвичай прихована від нас, але ми можемо її побачити в інструментах розробника. Наприклад, у Chrome нам знадобиться активувати опцію "Show user agent shadow DOM". 

Отже, `<input type="range">` виглядає так:

![](shadow-dom-range.png)

Те, що відображено під `#shadow-root` і є "тіньовим DOM" (shadow DOM).

Ми не можемо отримати доступ до тіньового DOM вбудованих елементів засобами звичайних JavaScript-викликів чи за допомогою селекторів. Це не просто звичайні нащадки, а потужний засіб інкапсуляції.

У вищенаведеному прикладі зверніть увагу на корисний атрибут `pseudo`. Він є нестандартним та існує через історичні причини. Його можна використовувати задля стилізації піделементи через CSS, наприклад, так:

```html run autorun
<style>
/* робимо слайдер повзунка червоним */
input::-webkit-slider-runnable-track {
  background: red;
}
</style>

<input type="range">
```

Наголошуємо, `pseudo` є нестандартним атрибутом. Хронологічно, браузери спочатку почали експерементувати з внутрішнімі DOM-структурами  для здійснення контролю, а потім, через певний час, тіньовий DOM було стандартизовано, щоб дати можливість нам, розробникам, робити те саме.

Надалі ми використовуватимемо сучасний тіньовий стандарт DOM, покритий [DOM специфікацією](https://dom.spec.whatwg.org/#shadow-trees) та іншими спорідненими специфікаціями.

## Тіньове дерево

DOM-елемент може мати два типи DOM піддерев:

1. Light tree -- звичайне "cвітле" DOM піддерево, що складається з HTML-нащадків. Усі піддерева, про які йшлося у попередніх розділах, були "cвітлі".
2. Shadow tree -- приховане "тіньове" DOM піддерево, не відображене у HTML та сховане від сторонніх очей.

Якщо елемент має обидва, то браузер відмальовує тільки тіньове дерево. Також ми можемо встановити певний вид композиції між тіньовим та світлим деревами. Ми обговоримо ці деталі надалі у розділі <info:slots-composition>.

Тіньове дерево може бути використаним в користувацьких елементах (сustom elements), щоб приховати внутрішній склад компонента і застосувати до нього локальні стилі.

Наприклад, цей `<show-hello>` елемент приховує свій внутрішній DOM у тіньовому дереві:

```html run autorun height=60
<script>
customElements.define('show-hello', class extends HTMLElement {
  connectedCallback() {
    const shadow = this.attachShadow({mode: 'open'});
    shadow.innerHTML = `<p>
      Hello, ${this.getAttribute('name')}
    </p>`;
  }  
});
</script>

<show-hello name="John"></show-hello>
```

Ось так отриманий DOM виглядає в інструментах розробника Chrome, увесь контент всередині "#shadow-root":

![](shadow-dom-say-hello.png)

По-перше, виклик `elem.attachShadow({mode: …})` створює тіньове дерево.

Існує два обмеження:
1. Для одного елементу можливо створити тільки один тіньовий root.
2. `elem` повинен бути або кастомним елементом, або одним з наступних:  "article", "aside", "blockquote", "body", "div", "footer", "h1..h6", "header", "main" "nav", "p", "section", or "span". Інші елементи, як `<img>`, не можуть містити тіньове дерево.

Опція `mode` встановлює рівень інкапсуляції, вона повинна мати одне з двох значень:
- `"open"` -- тіньовий root доступний як `elem.shadowRoot`.

    Будь-який код має доступ до тіньового дерева `elem`.   
- `"closed"` -- `elem.shadowRoot` завжди `null`.

    Ми можемо отримати доступ до тіньового DOM тільки по посиланню, яке повертається `attachShadow` (і, можливо, приховане у класі). Вбудовані браузерні нативні дерева, такі, як `<input type="range">`, є закритими, до них не дібратись.

[Тіньовий root](https://dom.spec.whatwg.org/#shadowroot), який повертає `attachShadow`, поводиться як елемент: ми можемо використовувати `innerHTML` чи DOM-методи, такі як `append`, щоб заповнити його.

Елемент з тіньового root називається "хазяїн" (shadow tree host) і доступний як властивість `host` у shadow root.

```js
// за умови {mode: "open"}, інакше elem.shadowRoot це null
alert(elem.shadowRoot.host === elem); // true
```

## Інкапсуляція

Тіньовий DOM цілковито відокремлений від основного документу:

1. Елементи тіньового DOM невидимі для `querySelector` зі світлого DOM. Зокрема, тіньовий DOM елемент може мати ідентифікатори, що конфліктують з одноіменними зі світлого DOM. Вони повинні бути унікальними тільки всередині тіньового дерева.
2. Тіньовий DOM має власні стилі. Стильові правила з зовнішнього DOM не застосовуються.

Наприклад:

```html run untrusted height=40
<style>
*!*
  /* стилі документа не застосовуються до тіньового дерева в середині #elem (1) */
*/!*
  p { color: red; }
</style>

<div id="elem"></div>

<script>
  elem.attachShadow({mode: 'open'});
*!*
    // тіньове дерево має власні стилі (2)
*/!*
  elem.shadowRoot.innerHTML = `
    <style> p { font-weight: bold; } </style>
    <p>Hello, John!</p>
  `;

*!*
  // <p> видимий тільки запитам зсередини тіньового дерева (3)
*/!*
  alert(document.querySelectorAll('p').length); // 0
  alert(elem.shadowRoot.querySelectorAll('p').length); // 1
</script>  
```

1. Стилі головного документу не впливають на тіньове дерево.
2. ...Але стиль зсередини працює.
3. Щоб дістатися елементів тіньового дерева, запит повинен виконуватись зсередини дерева.

## Довідки

- DOM: <https://dom.spec.whatwg.org/#shadow-trees>
- Сумісність: <https://caniuse.com/#feat=shadowdomv1>
- Тіньовий DOM згадується у багатьох інших специфікаціях, наприклад, [DOM Parsing](https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin) вказує на те, що у shadow root є `innerHTML`.

## Висновки

Тіньовий DOM – це спосіб створити ізольоване DOM-дерево для компонента.

1. `shadowRoot = elem.attachShadow({mode: open|closed})` -- створює тіньовий DOM для `elem`. Якщо `mode="open"`, то він є досяжним як властивість `elem.shadowRoot`.
2. Ми можемо створити піделементи  `shadowRoot`, використовуючи `innerHTML` чи інші методи DOM.

Тіньові елементи DOM:
- Мають власну область видимості ідентифікаторів;
- Невидимі для селекторів JavaScript з головного документу, таким, як `querySelector`;
- Використовують стилі тільки з тіньового дерева, не з головного документу.

Тіньовий DOM, якщо існує, рендериться браузером замість так званого "світлого DOM" (звичайних нащадків). У главі <info:slots-composition> ми розберемо, як поєднювати їх.
