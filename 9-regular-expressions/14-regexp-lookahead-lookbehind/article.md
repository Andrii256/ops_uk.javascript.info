# Перевірка уперед та назад

Іноді, нам потрібно знайти тільки такі співпадіння з шаблоном, за якими слідує, або яким передує інший шаблон.

Для цього існують спеціальні синтаксичні конструкції, котрі називається "перевірка уперед" та "перевірка назад".

Для початку, давайте знайдемо ціну у рядку `subject:1 індичка коштує 30€`. Маємо: число, за яким йде символ `subject:€`.

## Перевірка уперед

Синтаксис виглядає наступнм чином: `pattern:X(?=Y)`, це означає "шукай `pattern:X`, але вважай його співпадінням, тільки якщо за ним слідує `pattern:Y`". Замість `pattern:X` та `pattern:Y` можуть бути будь-які інші шаблони.

Для цілого числа, за яким слідує `subject:€`, регулярний вираз виглядатиме наступним чином `pattern:\d+(?=€)`:

```js run
let str = "1 індичка коштує 30€";

alert( str.match(/\d+(?=€)/) ); // 30, число 1 ігнорується, оскільки після нього не стоїть символ €
```

Зверніть увагу: перевірка уперед це свого роду тест, вміст в дужках `pattern:(?=...)` не входить до відображуваного регулярним виразом співпадіння `match:30`.

Коли ми шукаємо `pattern:X(?=Y)`, регулярний вираз знаходить `pattern:X` і далі перевіряє наявність `pattern:Y` одразу після нього. Якщо це не так, тоді потенційне співпадіння пропускається і регулярний вираз продовжує пошук.

Можливі і більш складні тести, наприклад `pattern:X(?=Y)(?=Z)` означає:

1. Знайди `pattern:X`.
2. Перевір, чи `pattern:Y` йде одразу після `pattern:X` (пропускай, якщо це не так).
3. Перевір, чи `pattern:Z` також йде одразу після `pattern:X` (пропускай, якщо це не так).
4. Якщо обидва тести пройдено, тоді `pattern:X` відповідає умовам пошуку, в інщому випадку -- продовжуй пошук.

Інакше кажучи, такий шаблон означає, що ми шукаємо на `pattern:X` за яким одночасно слідують `pattern:Y` та `pattern:Z`.

Це можливо тільки за умови, якщо шаблон `pattern:Y` та `pattern:Z` не виключають один одного.

Наприклад, `pattern:\d+(?=\s)(?=.*30)` шукає на `pattern:\d+` за яким йде пробільний символ `pattern:(?=\s)`, а також `30` десь після нього `pattern:(?=.*30)`:

```js run
let str = "1 індичка коштує 30€";

alert( str.match(/\d+(?=\s)(?=.*30)/) ); // 1
```

В нашому рядку цим параметрам повністю відповідає число `1`.

## Негативна перевірка уперед

Скажімо, ми хочем знайти кількість, а не ціну в тому самому рядку. Тобто, шукаємо число `pattern:\d+`, за якийм НЕ слідує `subject:€`.

В такому випадку, доречним буде використання негативного перегляду уперед.

Синтаксис виглядає наступним чином: `pattern:X(?!Y)`, і означає "шукай `pattern:X`, але за умови, що після нього не йде `pattern:Y`".

```js run
let str = "2 індички коштують 60€";

alert( str.match(/\d+\b(?!€)/g) ); // 2 (ціна не відповідає вимогам шаблону і не відображається в результаті)
```

## Перевірка назад

```warn header="Сумісність браузерів з перевіркою назад"
Зверніть увагу: Перевірка назад не підтримується в браузерах з відміннимим від V8 двигунами, зокрема Safari, Internet Explorer.
```

Перевірка уперед дозволяє додати умову на кшталт "те, що слідує після".

Перевірка назад подібна, але дивиться у зворотньому напрямку. Таким чином, вона видає результат, тільки якщо співпадає і шаблон і те, що йде до нього.

Синтаксис наступний:
- Позитивна перевірка назад: `pattern:(?<=Y)X`, співпадає з `pattern:X`, тільки за умови, якщо перед ним є `pattern:Y`.
- Негативна перевірка назад: `pattern:(?<!Y)X`, співпадає `pattern:X`, тільки за умови, якщо перед ним немає `pattern:Y`.

Наприклад, змінимо ціну з євро на американські долари. Знак долару зазвичай стоїть перед числом, тому, для пошуку `$30` ми використовуватимемо `pattern:(?<=\$)\d+` -- сума, перед якою є символ `subject:$`:

```js run
let str = "1 індичка коштує $30";

// знак долара екрановано \$
alert( str.match(/(?<=\$)\d+/) ); // 30 (число 1 пропущено через відсутність знаку долару перед ним)
```

Також, якщо нам потрібна кількість -- число, якому не передує `subject:$`, в такому випадку ми можемо використати негативну перевірку назад `pattern:(?<!\$)\d+`:

```js run
let str = "2 індички коштують $60";

alert( str.match(/(?<!\$)\b\d+/g) ); // 2 (ціна не співпадає з умовами пошуку)
```

## Дужкові групи

Зазвичай, в регулярних виразах вміст в дужках не є частиною співпадіння.

Наприклад, у шаблоні `pattern:\d+(?=€)`, символ `pattern:€` не відображається при виведенні співпадінь. Це нормально: ми шукаємо на число `pattern:\d+`, тоді як `pattern:(?=€)` це лише перевірка на те, чи дійсно за ним йде символ `subject:€`.

Але в деяких ситуаціях ми можемо також потребувати виведення вмісту цього шаблону або його частини. Це можливо. Просто огорніть потрібну частину в додаткові круглі дужки.

В нижченаведеному прикладі знак валюти `pattern:(€|kr)` теж відображено у результаті, разом із сумою:

```js run
let str = "1 індичка коштує 30€";
let regexp = /\d+(?=(€|kr))/; // додаткові круглі дужки навколо €|kr

alert( str.match(regexp) ); // 30, €
```

І так само для перегляду назад:

```js run
let str = "1 індичка коштує $30";
let regexp = /(?<=(\$|£))\d+/;

alert( str.match(regexp) ); // 30, $
```

## Підсумки

Перевірка уперед та назад корисні, коли нам потрібно знайти щось, залежно від контексту до чи після потрібного шаблону.

Для простих регулярних виразів ми можемо виконати подібну задачу вручну. Тобто: відшукати всі співпадіння, у будь-якому контексті, а потім відфільтрувати їх за контекстом за допомогою циклу.

Пам'ятайте, `str.match` (без прапорцю `pattern:g`) і `str.matchAll` (завжди) повертає співпадіння у вигляді масиву з властивістю `index`, тож ми точно знаємо де саме в тексті вони знаходяться і можемо перевірити контекст.

Але загалом перевірка уперед і назад більш підходящі.

Типи переглядів:

| Шаблон            | Тип             | Співпадіння |
|--------------------|------------------|---------|
| `X(?=Y)`   | Позитивна перевірка уперед | `pattern:X` якщо за ним йде `pattern:Y` |
| `X(?!Y)`   | Негативна перевірка уперед | `pattern:X` якщо за ним не йде `pattern:Y` |
| `(?<=Y)X` |  Позитивна перевірка назад  | `pattern:X` якщо він йде після `pattern:Y` |
| `(?<!Y)X` | Негативна перевірка назад | `pattern:X` якщо тільки він не йде після `pattern:Y` |
