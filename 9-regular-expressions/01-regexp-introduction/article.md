# Вступ: шаблони та прапорці

Регулярні вирази -- потужний засіб пошуку та заміни тексту в рядках.

В JavaScript регулярні вирази реалізовані окремим об’єктом [RegExp](mdn:js/RegExp) та інтегровані у методи рядків.

## Регулярні вирази

Регулярний вираз (він же "регексп", "регулярка" або просто "рег"), складається з *шаблону* (також кажуть "патерн") і необов’язкових *прапорців*.

Існує два синтаксиси для створення регулярного виразу.

"Довгий" синтаксис:

```js
regexp = new RegExp("шаблон", "прапорці");
```

Та "короткий" синтаксис, в якому використовуються слеши `"/"`:

```js
regexp = /шаблон/; // без прапорців
regexp = /шаблон/gmi; // з прапорцями g,m та i (будуть описані далі)
```

Слеши `pattern:/.../` говорять JavaScript про те, що це регулярний вираз. Вони відіграють таку саму роль, як і лапки для позначення рядків.

Регулярний вираз `regexp` в обох випадках є об’єктом вбудованого класу `RegExp`.

Основна різниця між цими двома синтаксами полягає в тому, що слеши `/.../` не допускають жодних вставок змінних (на зразок тих, що прописуються через `${...}`). Вони повністю статичні.

Слеши використовуються, коли ми на момент написання коду точно знаємо, яким буде регулярний вираз -- і це більшість ситуацій. А `new RegExp` -- коли ми хочемо створити регулярний вираз "на льоту" з динамічно згенерованого рядка, наприклад:

```js
let tag = prompt("Який тег ви хочете знайти?", "h2");

let regexp = new RegExp(`<${tag}>`); // те саме, що /<h2>/ при відповіді "h2" на запит вище
```

## Прапорці

Регулярні вирази можуть мати прапорці, які впливають на пошук.

У JavaScript їх всього шість:

`pattern:i`
: З цим прапорцем пошук не залежить від регістру: немає різниці між `A` та `a` (див. приклад нижче).

`pattern:g`
: З цим прапорцем пошук шукає всі збіги, без нього -- лише перший.

`pattern:m`
: Багаторядковий режим (розглядається в розділі <info:regexp-multiline-mode>).

`pattern:s`
: Вмикає режим "dotall", при якому крапка `pattern:.` може відповідати символу нового рядка `\n` (розглядається у розділі <info:regexp-character-classes>).

`pattern:u`
: Вмикає повну підтримку Юнікоду. Цей прапорець дозволяє коректну обробку сурогатних пар (докладніше про це у розділі <info:regexp-unicode>).

`pattern:y`
: Режим пошуку на конкретній позиції в тексті (описаний у розділі <info:regexp-sticky>)

```smart header="Кольорові позначення"
Тут і далі в тексті використовується наступна схема кольорів:

- регулярний вираз -- `pattern:червоний`
- рядок (там, де відбувається пошук) -- `subject:синій`
- результат -- `match:зелений`
```

## Пошук: str.match

Як вже згадувалося, регулярні вирази можна використовувати в методах рядків.

Метод `str.match(regexp)` для рядка `str` повертає збіги з регулярним виразом `regexp`.

У нього є три режими роботи:

1. Якщо в регулярного виразу є прапорець `pattern:g`, то він повертає масив всіх збігів:
     ```js run
     let str = "За Вас правда, за вас слава і воля святая!";
     alert(str.match(/вас/gi)); // Вас, вас (масив із 2х підрядків-збігів)
     ```
    Зверніть увагу: знайдено як `match:Вас` так і `match:вас`, завдяки прапорцю `pattern:i`, який робить регулярний вираз незалежним від регістру.

2. Якщо такого прапорця немає, то повертається лише перший збіг в масиві, де за індексом `0` знаходиться сам збіг, і є деякі властивості з додатковою інформацією про нього:
     ```js run
     let str = "За Вас правда, за вас слава і воля святая!";

     let result = str.match(/вас/i); // без прапорця g

     alert(result[0]); // Вас (перший збіг)
     alert(result.length); // 1

     // Додаткова інформація:
     alert(result.index); // 0 (позиція збігу)
     alert(result.input); // За Вас правда, за вас слава і воля святая! (вихідний рядок)
     ```
    У цьому масиві можуть бути інші індекси, крім `0`, якщо частина регулярного виразу виділена в дужки. Ми розберемо це у розділі <info:regexp-groups>.

3. І, нарешті, якщо збігів немає, то, незалежно від наявності прапорця `pattern:g`, повертається `null`.

    Це дуже важливий аспект. За відсутності збігів повертається не порожній масив, а саме `null`. Якщо про це забути, можна легко припуститися помилки, наприклад:

     ```js run
     let matches = "JavaScript". match(/HTML/); // = null
     if (!matches.length) { // Помилка: у null немає властивості length
       alert("Помилка у рядку вище");
     }
     ```

    Якщо хочеться, щоб результатом завжди був масив, можна написати так:

     ```js run
     let matches = "JavaScript".match(/HTML/)*!* || []*/!*;
     if (!matches.length) {
       alert("Збігів немає"); // тепер працює
     }
     ```

## Заміна: str.replace

Метод `str.replace(regexp, replacement)` замінює збіги з `regexp` у рядку `str` на `replacement` (всі збіги, якщо є прапорець `pattern:g`, інакше тільки перше).

Наприклад:

```js run
// без прапорця g
alert( "We will, we will".replace(/we/i, "I") ); // I will, we will

// з прапорцем g
alert( "We will, we will".replace(/we/ig, "I") ); // I will, I will
```

У рядку заміни `replacement` ми можемо використовувати спеціальні комбінації символів для вставки фрагментів збігу:

| Спецсимволи | Дія у рядку заміни |
|--------|--------|
|`$&`|вставляє всі знайдені збіги|
|<code>$&#096;</code>|вставляє частину рядка до збігу|
|`$'`|вставляє частину рядка після збігу|
|`$n`|якщо `n` це 1-2 значне число, вставляє вміст n-ої скобочної групи регулярного виразу, більше у розділі <info:regexp-groups>|
|`$<name>`|вставляє вміст скобочної групи з ім'ям `name`, також вивчимо у розділі <info:regexp-groups>|
|`$$`|вставляє символ `"$"` |

Приклад з `pattern:$&`:

```js run
alert( "Люблю HTML".replace(/HTML/, "$& і JavaScript") ); // Люблю HTML і JavaScript
```

## Перевірка: regexp.test

Метод `regexp.test(str)` перевіряє, чи є хоч один збіг, якщо так, то повертає `true`, інакше `false`.

```js run
let str = "Я люблю JavaScript";
let regexp = /люблю/i;

alert( regexp.test(str) ); // true
```

Далі в цьому розділі ми вивчатимемо регулярні вирази, побачимо ще багато прикладів їх використання, а також познайомимося з іншими методами.

Повна інформація про різні методи наведена в розділі <info:regexp-methods>.

## Підсумки

- Регулярний вираз складається з шаблону і необов’язкових прапорців: `pattern:g`, `pattern:i`, `pattern:m`, `pattern:u`, `pattern:s`, `pattern:y`.
- Без прапорців та спеціальних символів, які ми вивчимо пізніше, пошук за регулярним виразом аналогічний пошуку підрядка.
- Метод `str.match(regexp)` шукає збіги: всі, якщо є прапорець `pattern:g`, інакше тільки перший.
- Метод `str.replace(regexp, replacement)` замінює збіги з `regexp` на `replacement`: всі, якщо у регулярного виразу є прапорець `pattern:g`, інакше тільки перший.
- Метод `regexp.test(str)` повертає `true`, якщо є хоч один збіг, інакше `false`.
